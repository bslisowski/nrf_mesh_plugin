// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'network_key.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

NetworkKey _$NetworkKeyFromJson(Map<String, dynamic> json) {
  return _NetworkKey.fromJson(json);
}

/// @nodoc
mixin _$NetworkKey {
  String get name => throw _privateConstructorUsedError;
  int get netKeyIndex => throw _privateConstructorUsedError;
  int get phase => throw _privateConstructorUsedError;
  String get phaseDescription => throw _privateConstructorUsedError;
  bool get isMinSecurity => throw _privateConstructorUsedError;
  List<int> get netKeyBytes => throw _privateConstructorUsedError;
  List<int>? get oldNetKeyBytes => throw _privateConstructorUsedError;
  List<int> get txNetworkKey => throw _privateConstructorUsedError;
  List<int> get identityKey => throw _privateConstructorUsedError;
  List<int>? get oldIdentityKey => throw _privateConstructorUsedError;
  String get meshUuid => throw _privateConstructorUsedError;
  int get timestamp => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NetworkKeyCopyWith<NetworkKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkKeyCopyWith<$Res> {
  factory $NetworkKeyCopyWith(
          NetworkKey value, $Res Function(NetworkKey) then) =
      _$NetworkKeyCopyWithImpl<$Res>;
  $Res call(
      {String name,
      int netKeyIndex,
      int phase,
      String phaseDescription,
      bool isMinSecurity,
      List<int> netKeyBytes,
      List<int>? oldNetKeyBytes,
      List<int> txNetworkKey,
      List<int> identityKey,
      List<int>? oldIdentityKey,
      String meshUuid,
      int timestamp});
}

/// @nodoc
class _$NetworkKeyCopyWithImpl<$Res> implements $NetworkKeyCopyWith<$Res> {
  _$NetworkKeyCopyWithImpl(this._value, this._then);

  final NetworkKey _value;
  // ignore: unused_field
  final $Res Function(NetworkKey) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? netKeyIndex = freezed,
    Object? phase = freezed,
    Object? phaseDescription = freezed,
    Object? isMinSecurity = freezed,
    Object? netKeyBytes = freezed,
    Object? oldNetKeyBytes = freezed,
    Object? txNetworkKey = freezed,
    Object? identityKey = freezed,
    Object? oldIdentityKey = freezed,
    Object? meshUuid = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      netKeyIndex: netKeyIndex == freezed
          ? _value.netKeyIndex
          : netKeyIndex // ignore: cast_nullable_to_non_nullable
              as int,
      phase: phase == freezed
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
      phaseDescription: phaseDescription == freezed
          ? _value.phaseDescription
          : phaseDescription // ignore: cast_nullable_to_non_nullable
              as String,
      isMinSecurity: isMinSecurity == freezed
          ? _value.isMinSecurity
          : isMinSecurity // ignore: cast_nullable_to_non_nullable
              as bool,
      netKeyBytes: netKeyBytes == freezed
          ? _value.netKeyBytes
          : netKeyBytes // ignore: cast_nullable_to_non_nullable
              as List<int>,
      oldNetKeyBytes: oldNetKeyBytes == freezed
          ? _value.oldNetKeyBytes
          : oldNetKeyBytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      txNetworkKey: txNetworkKey == freezed
          ? _value.txNetworkKey
          : txNetworkKey // ignore: cast_nullable_to_non_nullable
              as List<int>,
      identityKey: identityKey == freezed
          ? _value.identityKey
          : identityKey // ignore: cast_nullable_to_non_nullable
              as List<int>,
      oldIdentityKey: oldIdentityKey == freezed
          ? _value.oldIdentityKey
          : oldIdentityKey // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      meshUuid: meshUuid == freezed
          ? _value.meshUuid
          : meshUuid // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$$_NetworkKeyCopyWith<$Res>
    implements $NetworkKeyCopyWith<$Res> {
  factory _$$_NetworkKeyCopyWith(
          _$_NetworkKey value, $Res Function(_$_NetworkKey) then) =
      __$$_NetworkKeyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String name,
      int netKeyIndex,
      int phase,
      String phaseDescription,
      bool isMinSecurity,
      List<int> netKeyBytes,
      List<int>? oldNetKeyBytes,
      List<int> txNetworkKey,
      List<int> identityKey,
      List<int>? oldIdentityKey,
      String meshUuid,
      int timestamp});
}

/// @nodoc
class __$$_NetworkKeyCopyWithImpl<$Res> extends _$NetworkKeyCopyWithImpl<$Res>
    implements _$$_NetworkKeyCopyWith<$Res> {
  __$$_NetworkKeyCopyWithImpl(
      _$_NetworkKey _value, $Res Function(_$_NetworkKey) _then)
      : super(_value, (v) => _then(v as _$_NetworkKey));

  @override
  _$_NetworkKey get _value => super._value as _$_NetworkKey;

  @override
  $Res call({
    Object? name = freezed,
    Object? netKeyIndex = freezed,
    Object? phase = freezed,
    Object? phaseDescription = freezed,
    Object? isMinSecurity = freezed,
    Object? netKeyBytes = freezed,
    Object? oldNetKeyBytes = freezed,
    Object? txNetworkKey = freezed,
    Object? identityKey = freezed,
    Object? oldIdentityKey = freezed,
    Object? meshUuid = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(_$_NetworkKey(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      netKeyIndex == freezed
          ? _value.netKeyIndex
          : netKeyIndex // ignore: cast_nullable_to_non_nullable
              as int,
      phase == freezed
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
      phaseDescription == freezed
          ? _value.phaseDescription
          : phaseDescription // ignore: cast_nullable_to_non_nullable
              as String,
      isMinSecurity == freezed
          ? _value.isMinSecurity
          : isMinSecurity // ignore: cast_nullable_to_non_nullable
              as bool,
      netKeyBytes == freezed
          ? _value._netKeyBytes
          : netKeyBytes // ignore: cast_nullable_to_non_nullable
              as List<int>,
      oldNetKeyBytes == freezed
          ? _value._oldNetKeyBytes
          : oldNetKeyBytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      txNetworkKey == freezed
          ? _value._txNetworkKey
          : txNetworkKey // ignore: cast_nullable_to_non_nullable
              as List<int>,
      identityKey == freezed
          ? _value._identityKey
          : identityKey // ignore: cast_nullable_to_non_nullable
              as List<int>,
      oldIdentityKey == freezed
          ? _value._oldIdentityKey
          : oldIdentityKey // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      meshUuid == freezed
          ? _value.meshUuid
          : meshUuid // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NetworkKey implements _NetworkKey {
  const _$_NetworkKey(
      this.name,
      this.netKeyIndex,
      this.phase,
      this.phaseDescription,
      this.isMinSecurity,
      final List<int> netKeyBytes,
      final List<int>? oldNetKeyBytes,
      final List<int> txNetworkKey,
      final List<int> identityKey,
      final List<int>? oldIdentityKey,
      this.meshUuid,
      this.timestamp)
      : _netKeyBytes = netKeyBytes,
        _oldNetKeyBytes = oldNetKeyBytes,
        _txNetworkKey = txNetworkKey,
        _identityKey = identityKey,
        _oldIdentityKey = oldIdentityKey;

  factory _$_NetworkKey.fromJson(Map<String, dynamic> json) =>
      _$$_NetworkKeyFromJson(json);

  @override
  final String name;
  @override
  final int netKeyIndex;
  @override
  final int phase;
  @override
  final String phaseDescription;
  @override
  final bool isMinSecurity;
  final List<int> _netKeyBytes;
  @override
  List<int> get netKeyBytes {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_netKeyBytes);
  }

  final List<int>? _oldNetKeyBytes;
  @override
  List<int>? get oldNetKeyBytes {
    final value = _oldNetKeyBytes;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int> _txNetworkKey;
  @override
  List<int> get txNetworkKey {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_txNetworkKey);
  }

  final List<int> _identityKey;
  @override
  List<int> get identityKey {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_identityKey);
  }

  final List<int>? _oldIdentityKey;
  @override
  List<int>? get oldIdentityKey {
    final value = _oldIdentityKey;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String meshUuid;
  @override
  final int timestamp;

  @override
  String toString() {
    return 'NetworkKey(name: $name, netKeyIndex: $netKeyIndex, phase: $phase, phaseDescription: $phaseDescription, isMinSecurity: $isMinSecurity, netKeyBytes: $netKeyBytes, oldNetKeyBytes: $oldNetKeyBytes, txNetworkKey: $txNetworkKey, identityKey: $identityKey, oldIdentityKey: $oldIdentityKey, meshUuid: $meshUuid, timestamp: $timestamp)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NetworkKey &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.netKeyIndex, netKeyIndex) &&
            const DeepCollectionEquality().equals(other.phase, phase) &&
            const DeepCollectionEquality()
                .equals(other.phaseDescription, phaseDescription) &&
            const DeepCollectionEquality()
                .equals(other.isMinSecurity, isMinSecurity) &&
            const DeepCollectionEquality()
                .equals(other._netKeyBytes, _netKeyBytes) &&
            const DeepCollectionEquality()
                .equals(other._oldNetKeyBytes, _oldNetKeyBytes) &&
            const DeepCollectionEquality()
                .equals(other._txNetworkKey, _txNetworkKey) &&
            const DeepCollectionEquality()
                .equals(other._identityKey, _identityKey) &&
            const DeepCollectionEquality()
                .equals(other._oldIdentityKey, _oldIdentityKey) &&
            const DeepCollectionEquality().equals(other.meshUuid, meshUuid) &&
            const DeepCollectionEquality().equals(other.timestamp, timestamp));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(netKeyIndex),
      const DeepCollectionEquality().hash(phase),
      const DeepCollectionEquality().hash(phaseDescription),
      const DeepCollectionEquality().hash(isMinSecurity),
      const DeepCollectionEquality().hash(_netKeyBytes),
      const DeepCollectionEquality().hash(_oldNetKeyBytes),
      const DeepCollectionEquality().hash(_txNetworkKey),
      const DeepCollectionEquality().hash(_identityKey),
      const DeepCollectionEquality().hash(_oldIdentityKey),
      const DeepCollectionEquality().hash(meshUuid),
      const DeepCollectionEquality().hash(timestamp));

  @JsonKey(ignore: true)
  @override
  _$$_NetworkKeyCopyWith<_$_NetworkKey> get copyWith =>
      __$$_NetworkKeyCopyWithImpl<_$_NetworkKey>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NetworkKeyToJson(
      this,
    );
  }
}

abstract class _NetworkKey implements NetworkKey {
  const factory _NetworkKey(
      final String name,
      final int netKeyIndex,
      final int phase,
      final String phaseDescription,
      final bool isMinSecurity,
      final List<int> netKeyBytes,
      final List<int>? oldNetKeyBytes,
      final List<int> txNetworkKey,
      final List<int> identityKey,
      final List<int>? oldIdentityKey,
      final String meshUuid,
      final int timestamp) = _$_NetworkKey;

  factory _NetworkKey.fromJson(Map<String, dynamic> json) =
      _$_NetworkKey.fromJson;

  @override
  String get name;
  @override
  int get netKeyIndex;
  @override
  int get phase;
  @override
  String get phaseDescription;
  @override
  bool get isMinSecurity;
  @override
  List<int> get netKeyBytes;
  @override
  List<int>? get oldNetKeyBytes;
  @override
  List<int> get txNetworkKey;
  @override
  List<int> get identityKey;
  @override
  List<int>? get oldIdentityKey;
  @override
  String get meshUuid;
  @override
  int get timestamp;
  @override
  @JsonKey(ignore: true)
  _$$_NetworkKeyCopyWith<_$_NetworkKey> get copyWith =>
      throw _privateConstructorUsedError;
}
